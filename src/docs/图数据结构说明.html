<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图数据结构说明 - SAEV运营优化文档</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1, h2, h3, h4, h5, h6 { color: #333; }
        code { background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
        pre { background-color: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .toc { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    </style>
</head>
<body>
<h1 id="saev-">网络化SAEV运营优化项目 - 图数据结构说明</h1>
<h2 id="_1">项目概述</h2>
<p>本项目实现了一个基于时空-电量网格的最小费用流优化模型，用于优化共享自动驾驶电动汽车(SAEV)的运营。模型在离散化的时空-电量网格上构建图结构，通过最小费用流算法求解最优的车辆调度方案。</p>
<h2 id="_2">新增功能特性</h2>
<h3 id="_3">可视化分析系统</h3>
<ul>
<li><strong>SAEVResultVisualizer</strong>: 完整的求解结果可视化工具</li>
<li><strong>多维度分析</strong>: 流量分布、成本效益、时空演化、网络拓扑</li>
<li><strong>交互式图表</strong>: 支持plotly、folium等交互式可视化</li>
<li><strong>自动化报告</strong>: 生成完整的分析报告</li>
</ul>
<h3 id="_4">管道执行系统</h3>
<ul>
<li><strong>run_pipeline.py</strong>: 支持顺序执行多个脚本步骤</li>
<li><strong>日志记录</strong>: 完整的执行日志和错误处理</li>
<li><strong>超时控制</strong>: 可配置的执行超时机制</li>
<li><strong>重试机制</strong>: 支持失败重试</li>
</ul>
<h3 id="_5">增强的求解器</h3>
<ul>
<li><strong>负环检测</strong>: 求解前自动检测负成本环</li>
<li><strong>多求解器支持</strong>: GLPK、CBC等求解器</li>
<li><strong>性能优化</strong>: 大规模问题的求解优化</li>
</ul>
<h3 id="_6">配置系统</h3>
<ul>
<li><strong>NetworkConfig</strong>: 统一的配置管理类</li>
<li><strong>模块化配置</strong>: 支持分模块的配置管理</li>
<li><strong>默认值</strong>: 所有配置参数都有合理的默认值</li>
</ul>
<h2 id="1">1. 图的节点类型</h2>
<h3 id="11-grid-nodes">1.1 真实网格节点 (Grid Nodes)</h3>
<p><strong>节点表示</strong>: <code>(i, t, ℓ)</code>
- <code>i</code>: 区域ID (zone)，来自 <code>zones.csv</code>
- <code>t</code>: 时间步 (time step)，离散化时间点
- <code>ℓ</code>: 电量等级 (SOC level)，0-100的离散电量值</p>
<p><strong>节点ID编码</strong>: 
$$node_id = (z_i \times n_t + t_i) \times n_l + l_i$$
其中 $z_i$, $t_i$, $l_i$ 分别是区域、时间、电量的索引。</p>
<p><strong>节点属性</strong>:
- <code>node_id</code>: 唯一节点标识符
- <code>zone</code>: 区域ID
- <code>t</code>: 时间步
- <code>soc</code>: 电量等级
- <code>supply</code>: 节点供给量（仅初始时刻t₀有正供给）</p>
<h3 id="12-pseudo-nodes">1.2 伪节点 (Pseudo Nodes)</h3>
<h4 id="121">1.2.1 服务闸门节点</h4>
<ul>
<li><strong><code>svc_in(i,j,t)</code></strong>: 服务进入闸门节点</li>
<li><strong><code>svc_out(i,j,t)</code></strong>: 服务退出闸门节点</li>
</ul>
<p>用于将服务需求约束与时空推进解耦，实现"闸门弧"模式。</p>
<h4 id="122">1.2.2 充电队列节点</h4>
<ul>
<li><strong><code>q_in(k,p)</code></strong>: 充电站k在时间步p的进入队列节点</li>
<li><strong><code>q_out(k,p)</code></strong>: 充电站k在时间步p的退出队列节点</li>
</ul>
<p>用于建模充电站的并发容量约束。</p>
<h4 id="123">1.2.3 超级汇点 (可选)</h4>
<ul>
<li><strong><code>sink</code></strong>: 超级汇点，用于平衡网络流</li>
</ul>
<p><strong>伪节点ID生成</strong>:
<code>python
def _pseudo_node_id(kind: str, *keys) -&gt; int:
    s = f"{kind}|" + "|".join(map(str, keys))
    digest = hashlib.blake2b(s.encode('utf-8'), digest_size=8).digest()
    val = int.from_bytes(digest, byteorder='big', signed=False) &amp; 0x7FFFFFFFFFFFFFFF
    return -int(val)  # 负数，避免与网格节点冲突</code></p>
<h2 id="2">2. 图的边类型</h2>
<h3 id="21">2.1 基础弧类型</h3>
<h4 id="211-idle-arcs">2.1.1 空闲弧 (Idle Arcs)</h4>
<ul>
<li><strong>类型</strong>: <code>idle</code></li>
<li><strong>连接</strong>: $(i,t,\ell) \rightarrow (i,t+1,\ell)$</li>
<li><strong>含义</strong>: 车辆在区域i停留一个时间步，电量不变</li>
<li><strong>时间消耗</strong>: $\tau = 1$步</li>
<li><strong>电量消耗</strong>: 0</li>
</ul>
<h4 id="212-reposition-arcs">2.1.2 重定位弧 (Reposition Arcs)</h4>
<ul>
<li><strong>类型</strong>: <code>reposition</code></li>
<li><strong>连接</strong>: $(i,t,\ell) \rightarrow (j,t+\tau,\ell-\Delta\ell)$</li>
<li><strong>含义</strong>: 车辆从区域i重定位到区域j</li>
<li><strong>时间消耗</strong>: $\tau = \lceil \text{base_minutes}/dt \rceil$</li>
<li><strong>电量消耗</strong>: $\Delta\ell = \text{compute_multi_timestep_energy_consumption}()$</li>
<li><strong>约束</strong>: </li>
<li>$\ell \geq \max{\Delta\ell, \text{min_soc_for_reposition}}$</li>
<li>$\tau \leq \text{max_reposition_tt}$</li>
<li>起终点都在可达性集合R中</li>
</ul>
<h3 id="22-service-arcs-">2.2 服务弧 (Service Arcs) - 三段式结构</h3>
<h4 id="221">2.2.1 服务进入弧</h4>
<ul>
<li><strong>类型</strong>: <code>svc_enter</code></li>
<li><strong>连接</strong>: $(i,t,\ell) \rightarrow \text{svc_in}(i,j,t)$</li>
<li><strong>含义</strong>: 车辆进入服务闸门</li>
<li><strong>时间消耗</strong>: $\tau = 0$</li>
<li><strong>电量消耗</strong>: 0</li>
</ul>
<h4 id="222">2.2.2 服务闸门弧</h4>
<ul>
<li><strong>类型</strong>: <code>svc_gate</code></li>
<li><strong>连接</strong>: $\text{svc_in}(i,j,t) \rightarrow \text{svc_out}(i,j,t)$</li>
<li><strong>含义</strong>: 服务需求约束的容量弧</li>
<li><strong>容量</strong>: $u = D_{ijt}$ (当期需求)</li>
<li><strong>成本</strong>: 负成本奖励 $-VOT \times w_{ijt}$</li>
<li><strong>时间消耗</strong>: $\tau = 0$</li>
</ul>
<h4 id="223">2.2.3 服务退出弧</h4>
<ul>
<li><strong>类型</strong>: <code>svc_exit</code></li>
<li><strong>连接</strong>: $\text{svc_out}(i,j,t) \rightarrow (j,t+\tau,\ell-\Delta\ell)$</li>
<li><strong>含义</strong>: 车辆完成服务，到达目的地</li>
<li><strong>时间消耗</strong>: $\tau = \lceil \text{base_minutes}/dt \rceil$</li>
<li><strong>电量消耗</strong>: $\Delta\ell = \text{compute_multi_timestep_energy_consumption}()$</li>
</ul>
<h3 id="23-charging-arcs-">2.3 充电弧 (Charging Arcs) - 四段式结构</h3>
<h4 id="231">2.3.1 去充电站弧</h4>
<ul>
<li><strong>类型</strong>: <code>tochg</code></li>
<li><strong>连接</strong>: $(i,t,\ell) \rightarrow (\text{zone}(k),t+\tau,\ell-\Delta\ell)$</li>
<li><strong>含义</strong>: 车辆前往充电站k</li>
<li><strong>时间消耗</strong>: $\tau = \lceil \text{dist_km}/(\text{avg_speed_kmh}/60)/dt \rceil$</li>
<li><strong>电量消耗</strong>: $\Delta\ell = \text{compute_multi_timestep_energy_consumption}()$</li>
</ul>
<h4 id="232">2.3.2 充电进入弧</h4>
<ul>
<li><strong>类型</strong>: <code>chg_enter</code></li>
<li><strong>连接</strong>: $(\text{zone}(k),p,\ell) \rightarrow q_\text{in}(k,p)$</li>
<li><strong>含义</strong>: 车辆进入充电站队列</li>
<li><strong>时间消耗</strong>: $\tau = 0$</li>
<li><strong>电量消耗</strong>: 0</li>
</ul>
<h4 id="233">2.3.3 充电占用弧</h4>
<ul>
<li><strong>类型</strong>: <code>chg_occ</code></li>
<li><strong>连接</strong>: $q_\text{in}(k,p) \rightarrow q_\text{out}(k,p)$</li>
<li><strong>含义</strong>: 充电站并发容量约束</li>
<li><strong>容量</strong>: $u = \max{1, \lfloor \text{plugs}_k \times \text{util_factor}_k \times \text{queue_relax_factor} \rfloor}$</li>
<li><strong>成本</strong>: $VOT \times \beta_{\text{chg_p2}}(p)$</li>
<li><strong>时间消耗</strong>: $\tau = 0$</li>
</ul>
<h4 id="234">2.3.4 充电推进弧</h4>
<ul>
<li><strong>类型</strong>: <code>chg_step</code></li>
<li><strong>连接</strong>: $q_\text{out}(k,p) \rightarrow (\text{zone}(k),p+1,\ell')$</li>
<li><strong>含义</strong>: 充电时间推进，最后一步提升电量</li>
<li><strong>时间消耗</strong>: $\tau = 1$</li>
<li><strong>电量变化</strong>: </li>
<li>最后一步: $\ell' = \text{target_soc}$</li>
<li>其他步骤: $\ell' = \ell$</li>
</ul>
<h3 id="24">2.4 超级汇点弧 (可选)</h3>
<ul>
<li><strong>类型</strong>: <code>to_sink</code></li>
<li><strong>连接</strong>: $(i,t_{\text{hi}},\ell) \rightarrow \text{sink}$</li>
<li><strong>含义</strong>: 窗口结束时的流量平衡</li>
<li><strong>容量</strong>: 大数 ($10^{12}$)</li>
<li><strong>成本</strong>: cost_to_sink (默认0)</li>
</ul>
<h2 id="3">3. 边的权重属性</h2>
<h3 id="31">3.1 成本系数结构</h3>
<p>每条弧的总成本由以下组件构成：
$$c_{\text{total}} = c_{\text{rep}} + c_{\text{chg_travel}} + c_{\text{occ}} + c_{\text{svc_gate}} + c_{\text{rep_reward}} + c_{\text{chg_reward}}$$</p>
<h3 id="32-coeffprovider">3.2 系数调度器 (CoeffProvider)</h3>
<p>系统使用 <code>CoeffProvider</code> 类来管理时间可变的成本系数：</p>
<h4 id="321">3.2.1 系数来源</h4>
<ul>
<li><strong>主要来源</strong>: <code>coeff_schedule.csv</code> 文件，包含列 <code>[t, gamma_rep_p, beta_chg_p1, beta_chg_p2]</code></li>
<li><strong>后备来源</strong>: 配置文件中的常数 <code>[gamma_rep, beta_toCHG, beta_chg]</code></li>
<li><strong>VOT系数</strong>: 时间价值系数，来自配置 <code>cfg.costs_equity.vot</code>（默认1.0）</li>
</ul>
<h4 id="322">3.2.2 系数获取函数</h4>
<p>```python
def gamma_rep_p(self, t: int) -&gt; float:
    """重定位时间成本系数"""
    return self.map_gamma_rep_p.get(int(t), self.gamma_rep_p_const)</p>
<p>def beta_chg_p1(self, t: int) -&gt; float:
    """去充电行驶成本系数"""
    return self.map_beta_chg_p1.get(int(t), self.beta_chg_p1_const)</p>
<p>def beta_chg_p2(self, t: int) -&gt; float:
    """充电占位成本系数"""
    return self.map_beta_chg_p2.get(int(t), self.beta_chg_p2_const)
```</p>
<h4 id="323">3.2.3 区间累加函数</h4>
<p>```python
def gamma_rep_p_sum_over_window(self, t_start: int, tau: int) -&gt; float:
    """重定位成本在时间窗口内的累加"""
    if tau &lt;= 0: return 0.0
    if not self.has_schedule: return tau * self.gamma_rep_p_const
    return sum(self.gamma_rep_p(tp) for tp in range(t_start, t_start + tau))</p>
<p>def beta_chg_p1_sum_over_window(self, t_start: int, tau: int) -&gt; float:
    """去充电行驶成本在时间窗口内的累加"""
    if tau &lt;= 0: return 0.0
    if not self.has_schedule: return tau * self.beta_chg_p1_const
    return sum(self.beta_chg_p1(tp) for tp in range(t_start, t_start + tau))</p>
<p>def beta_chg_p2_sum_over_window(self, t_start: int, tau_tochg: int, tau_chg: int) -&gt; float:
    """充电占位成本在充电时间内的累加"""
    if tau_chg &lt;= 0: return 0.0
    if not self.has_schedule: return tau_chg * self.beta_chg_p2_const
    s_begin = t_start + tau_tochg
    return sum(self.beta_chg_p2(tp) for tp in range(s_begin, s_begin + tau_chg))
```</p>
<h3 id="33-c_rep">3.3 重定位成本 (c_rep)</h3>
<ul>
<li><strong>适用弧</strong>: <code>reposition</code></li>
<li><strong>数学函数</strong>: 
  $$c_{\text{rep}} = VOT \times \sum_{q=0}^{\tau-1} \gamma_{\text{rep_p}}(t+q)$$</li>
<li><strong>实现函数</strong>: <code>build_reposition_cost_coefficients_from_arcs()</code></li>
<li><strong>含义</strong>: 重定位过程中的时间成本</li>
<li><strong>系数来源</strong>: <code>coeff_schedule.csv</code> 或配置常数 <code>cfg.costs_equity.gamma_rep</code>（默认1.0）</li>
</ul>
<h3 id="34-c_chg_travel">3.4 去充电行驶成本 (c_chg_travel)</h3>
<ul>
<li><strong>适用弧</strong>: <code>tochg</code></li>
<li><strong>数学函数</strong>:
  $$c_{\text{chg_travel}} = VOT \times \sum_{q=0}^{\tau-1} \beta_{\text{chg_p1}}(t+q)$$</li>
<li><strong>实现函数</strong>: <code>build_charging_travel_costs_from_arcs()</code></li>
<li><strong>含义</strong>: 前往充电站的时间成本</li>
<li><strong>系数来源</strong>: <code>coeff_schedule.csv</code> 或配置常数 <code>cfg.costs_equity.beta_toCHG</code>（默认1.0）</li>
</ul>
<h3 id="35-c_occ">3.5 充电占位成本 (c_occ)</h3>
<ul>
<li><strong>适用弧</strong>: <code>chg_occ</code></li>
<li><strong>数学函数</strong>:
  $$c_{\text{occ}} = VOT \times \beta_{\text{chg_p2}}(p)$$</li>
<li><strong>实现函数</strong>: <code>build_charging_occupancy_costs_from_arcs()</code></li>
<li><strong>含义</strong>: 充电站占用的时间成本</li>
<li><strong>系数来源</strong>: <code>coeff_schedule.csv</code> 或配置常数 <code>cfg.costs_equity.beta_chg</code>（默认1.0）</li>
</ul>
<h3 id="36-c_svc_gate-">3.6 服务奖励 (c_svc_gate) - 负成本</h3>
<ul>
<li><strong>适用弧</strong>: <code>svc_gate</code></li>
<li><strong>数学函数</strong>:
  $$c_{\text{svc_gate}} = -VOT \times w_{ijt}$$</li>
<li><strong>实现函数</strong>: <code>build_service_reward_coefficients()</code></li>
<li><strong>含义</strong>: 服务需求的奖励，鼓励满足需求</li>
<li><strong>权重计算</strong>:
  $$w_{ijt} = \text{cfg.costs_equity.unmet_weight_default} \quad \text{(默认权重，默认1.0)}$$
  $$w_{ijt} = \text{cfg.unmet_weights_overrides}(t,i,j) \quad \text{(特定组合覆盖)}$$</li>
<li><strong>控制开关</strong>: <code>cfg.flags.enable_service_reward</code></li>
</ul>
<h3 id="37-c_rep_reward-">3.7 重定位收益 (c_rep_reward) - 负成本</h3>
<ul>
<li><strong>适用弧</strong>: <code>reposition</code></li>
<li><strong>数学函数</strong>:
  $$c_{\text{rep_reward}} = -\gamma_{\text{rep}} \times \text{zone_value}(t,j)$$</li>
<li><strong>实现函数</strong>: <code>build_zone_value_table()</code> + 重定位收益计算</li>
<li><strong>含义</strong>: 重定位到高需求区域的收益</li>
<li><strong>区域价值计算</strong>:
  $$\text{zone_value_raw}(t,j) = \max\left{\sum_i D_{ijt}^{\text{out}} - \text{inv}_0(j), 0\right}$$
  $$\text{zone_value}(t,j) = \text{normalize}(\text{zone_value_raw}(t,j)) \quad \text{(归一化到 [0,1])}$$</li>
<li><strong>归一化模式</strong>:</li>
<li><code>per_t_sum</code>: 按时段总和归一化</li>
<li><code>per_t_max</code>: 按时段最大值归一化</li>
<li><code>global_max</code>: 全局最大值归一化</li>
<li><code>window_sum</code>: 窗口总和归一化</li>
<li><code>none</code>: 不归一化</li>
<li><strong>系数来源</strong>: <code>cfg.costs_equity.gamma_reposition_reward</code>（默认1.0）</li>
<li><strong>控制开关</strong>: <code>cfg.flags.enable_reposition_reward</code></li>
</ul>
<h3 id="38-c_chg_reward-">3.8 充电收益 (c_chg_reward) - 负成本</h3>
<ul>
<li><strong>适用弧</strong>: <code>chg_occ</code>, <code>chg_step</code></li>
<li><strong>数学函数</strong>:
  $$c_{\text{chg_reward}} = -\alpha_{\text{chg}} \times \max{\ell_{\text{to}} - \ell, 0}$$</li>
<li><strong>实现函数</strong>: 基于 <code>chg_step</code> 弧的SOC变化计算</li>
<li><strong>含义</strong>: 充电电量提升的收益</li>
<li><strong>SOC变化计算</strong>:
  $$d_{\text{soc}} = (\ell_{\text{to}} - \ell) \cdot \text{clip}(\text{lower}=0) \quad \text{(只计算正的电量提升)}$$
  $$c_{\text{chg_reward}} = -\beta_{\text{chg_reward}} \times d_{\text{soc}}$$</li>
<li><strong>系数来源</strong>: <code>cfg.costs_equity.beta_chg_reward</code>（默认1.0）</li>
<li><strong>控制开关</strong>: <code>cfg.flags.enable_charging_reward</code></li>
<li><strong>注意</strong>: 当前实现中主要基于 <code>chg_step</code> 弧的 <code>l_to</code> 列计算</li>
</ul>
<h3 id="39">3.9 成本合并机制</h3>
<h4 id="391">3.9.1 成本系数合并函数</h4>
<p>```python
def attach_costs_to_arcs_for_window(arc_df_win: pd.DataFrame) -&gt; pd.DataFrame:
    """将各种成本系数合并到弧表中"""
    # 1. 计算各类成本系数
    parts = build_cost_coefficients_for_window(arc_df_win)</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="mi">2</span><span class="p">.</span><span class="w"> </span><span class="nx">按弧类型合并成本</span>
<span class="nx">out</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arc_df_win</span><span class="p">.</span><span class="nx">copy</span><span class="p">()</span>
<span class="k">for</span><span class="w"> </span><span class="nx">cost_type</span><span class="p">,</span><span class="w"> </span><span class="nx">coef_df</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">parts</span><span class="p">.</span><span class="nx">items</span><span class="p">():</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">coef_df</span><span class="p">.</span><span class="nx">empty</span><span class="p">:</span>
<span class="w">        </span><span class="nx">out</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">_merge_with_keys</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span><span class="w"> </span><span class="nx">coef_df</span><span class="p">,</span><span class="w"> </span><span class="nx">keys</span><span class="p">,</span><span class="w"> </span><span class="nx">coef_col</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="w"> </span><span class="nx">计算总成本</span>
<span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_total&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_rep&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_chg_travel&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_chg_occ&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_svc_gate&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_rep_reward&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">out</span><span class="p">[</span><span class="s">&quot;coef_chg_reward&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="k">return</span><span class="w"> </span><span class="nx">out</span>
</code></pre></div>

<p>```</p>
<h4 id="392">3.9.2 安全合并函数</h4>
<p>```python
def _merge_with_keys(flow_df: pd.DataFrame, coef_df: pd.DataFrame, 
                    keys: List[str], coef_col: str) -&gt; pd.DataFrame:
    """安全合并成本系数，避免列冲突"""
    # 优先使用 arc_id 作为合并键
    if "arc_id" in flow_df.columns and "arc_id" in coef_df.columns:
        use_keys = ["arc_id"]
    else:
        use_keys = [k for k in keys if (k in flow_df.columns and k in coef_df.columns)]</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="n">合并并处理</span><span class="w"> </span><span class="n">NaN</span><span class="o">/</span><span class="err">±</span><span class="n">inf</span><span class="w"> </span><span class="n">值</span>
<span class="n">merged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flow_df</span><span class="p">.</span><span class="k">merge</span><span class="p">(</span><span class="n">coef_df</span><span class="p">,</span><span class="w"> </span><span class="k">on</span><span class="o">=</span><span class="n">use_keys</span><span class="p">,</span><span class="w"> </span><span class="n">how</span><span class="o">=</span><span class="ss">&quot;left&quot;</span><span class="p">)</span>
<span class="n">merged</span><span class="o">[</span><span class="n">coef_col</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_to_finite_float</span><span class="p">(</span><span class="n">merged</span><span class="o">[</span><span class="n">coef_col</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>

<span class="k">return</span><span class="w"> </span><span class="n">merged</span>
</code></pre></div>

<p>```</p>
<h4 id="393">3.9.3 数值安全处理</h4>
<p><code>python
def _to_finite_float(s: pd.Series, default: float = 0.0) -&gt; pd.Series:
    """将序列安全转换为有限浮点数"""
    x = pd.to_numeric(s, errors="coerce")
    x = x.where(np.isfinite(x), default)
    return x.astype(float)</code></p>
<h3 id="310">3.10 容量约束</h3>
<h4 id="3101">3.10.1 服务闸门容量</h4>
<ul>
<li><strong>弧类型</strong>: <code>svc_gate</code></li>
<li><strong>容量</strong>: $u = D_{ijt}$ (当期需求)</li>
<li><strong>含义</strong>: 限制当期可服务的最大需求</li>
</ul>
<h4 id="3102">3.10.2 充电站容量</h4>
<ul>
<li><strong>弧类型</strong>: <code>chg_occ</code></li>
<li><strong>容量</strong>: $u = \max{1, \lfloor \text{plugs}_k \times \text{util_factor}_k \times \text{queue_relax_factor} \rfloor}$</li>
<li><strong>含义</strong>: 限制充电站的并发充电数量</li>
</ul>
<h4 id="3103">3.10.3 其他弧容量</h4>
<ul>
<li><strong>默认容量</strong>: 大数 ($10^{12}$)</li>
<li><strong>含义</strong>: 仅由供给和连通性间接限流</li>
</ul>
<h2 id="4">4. 图构建流程</h2>
<h3 id="41-_02_build_time_soc_gridpy">4.1 网格构建 (_02_build_time_soc_grid.py)</h3>
<ol>
<li>从 <code>zones.csv</code> 读取区域集合</li>
<li>构建时间步序列 [start_step, end_step + overhang_steps]</li>
<li>构建SOC等级序列 [0, 5, 10, ..., 100]</li>
<li>生成所有 (zone, time, soc) 组合的网格节点</li>
<li>从 <code>fleet_init.csv</code> 加载初始库存</li>
</ol>
<h3 id="42-_03_reachabilitypy">4.2 可达性分析 (_03_reachability.py)</h3>
<ol>
<li>为每个区域选择最近充电站集合</li>
<li>计算到站能耗</li>
<li>构建可达性集合R，确保车辆能到达所有最近充电站</li>
</ol>
<h3 id="43-_04_arc_generatorspy">4.3 弧生成 (_04_arc_generators.py)</h3>
<ol>
<li>生成idle弧</li>
<li>生成service弧（三段式）</li>
<li>生成reposition弧</li>
<li>生成charging弧（四段式）</li>
<li>移除自环</li>
</ol>
<h3 id="44-_05_connectivitypy">4.4 连通性裁剪 (_05_connectivity.py)</h3>
<ol>
<li>从初始库存构建源节点集合</li>
<li>使用BFS进行前向/后向连通性分析</li>
<li>保留连通弧，移除孤立弧</li>
</ol>
<h3 id="45-_06_costspy">4.5 成本附加 (_06_costs.py)</h3>
<ol>
<li>计算各类弧的成本系数</li>
<li>合并成本组件</li>
<li>设置容量约束</li>
</ol>
<h3 id="46-_08_build_solver_graphpy">4.6 求解器图构建 (_08_build_solver_graph.py)</h3>
<ol>
<li>整合所有组件</li>
<li>生成节点供给向量</li>
<li>可选添加超级汇点</li>
<li>输出求解器可用的图结构</li>
</ol>
<h3 id="47-_09_solve_graph_mincostpy">4.7 最小费用流求解 (_09_solve_graph_mincost.py)</h3>
<ol>
<li>读取求解器图结构</li>
<li>负环检测（可选）</li>
<li>构建线性规划模型</li>
<li>选择求解器并求解</li>
<li>输出最优流量分配</li>
</ol>
<h3 id="48-visualize_solver_resultspy">4.8 结果可视化 (visualize_solver_results.py)</h3>
<ol>
<li>加载求解结果</li>
<li>多维度分析</li>
<li>生成可视化图表</li>
<li>输出分析报告</li>
</ol>
<h2 id="5">5. 关键特性</h2>
<h3 id="51">5.1 滚动窗口优化</h3>
<ul>
<li>仅生成出发时刻在窗口内的弧</li>
<li>允许到达时刻跨窗口（Halo机制）</li>
<li>支持动态弧生成</li>
</ul>
<h3 id="52">5.2 伪节点设计</h3>
<ul>
<li>将容量约束与时空推进解耦</li>
<li>实现"闸门弧"和"占用链"模式</li>
<li>保持网络流的线性特性</li>
</ul>
<h3 id="53">5.3 可达性约束</h3>
<ul>
<li>确保车辆始终能到达充电站</li>
<li>使用ALL-NEAREST策略</li>
<li>动态SOC约束</li>
</ul>
<h3 id="54">5.4 成本结构</h3>
<ul>
<li>时间可变成本系数</li>
<li>负成本奖励机制</li>
<li>多目标平衡（成本最小化 + 需求满足）</li>
</ul>
<h3 id="55">5.5 配置系统</h3>
<ul>
<li>统一的配置管理</li>
<li>模块化配置结构</li>
<li>默认值支持</li>
</ul>
<h3 id="56">5.6 可视化系统</h3>
<ul>
<li>多维度分析</li>
<li>交互式图表</li>
<li>自动化报告生成</li>
</ul>
<h3 id="57">5.7 管道执行</h3>
<ul>
<li>顺序执行多个步骤</li>
<li>日志记录和错误处理</li>
<li>重试机制</li>
</ul>
<h2 id="6">6. 数据文件依赖</h2>
<h3 id="61">6.1 输入文件</h3>
<ul>
<li><code>zones.csv</code>: 区域定义</li>
<li><code>stations.csv</code>: 充电站信息</li>
<li><code>od_matrix.parquet</code>: 出行需求矩阵</li>
<li><code>base_ij.parquet</code>: 区域间基础信息</li>
<li><code>base_i2k.parquet</code>: 区域到充电站信息</li>
<li><code>coeff_schedule.csv</code>: 时间可变成本系数</li>
<li><code>coeff_energy.csv</code>: 能耗系数</li>
<li><code>fleet_init.csv</code>: 初始车队分布</li>
</ul>
<h3 id="62">6.2 中间文件</h3>
<ul>
<li><code>nodes.parquet</code>: 网格节点表</li>
<li><code>initial_inventory.parquet</code>: 初始库存</li>
<li><code>reachability.parquet</code>: 可达性表</li>
<li><code>*_arcs.parquet</code>: 各类弧表</li>
<li><code>node_indexer.pkl</code>: 节点索引器</li>
</ul>
<h3 id="63">6.3 输出文件</h3>
<ul>
<li><code>solver_graph/nodes.parquet</code>: 求解器节点表</li>
<li><code>solver_graph/arcs.parquet</code>: 求解器弧表</li>
<li><code>solver_graph/meta.json</code>: 图元数据</li>
<li><code>outputs/flows.parquet</code>: 最优流量分配</li>
<li><code>outputs/solve_summary.json</code>: 求解结果摘要</li>
</ul>
<h3 id="64">6.4 可视化输出</h3>
<ul>
<li><code>flow_summary.png</code>: 流量汇总分析图</li>
<li><code>spatiotemporal_flow.html</code>: 时空流量演化图</li>
<li><code>interactive_map.html</code>: 交互式地图</li>
<li><code>dashboard.html</code>: 综合仪表板</li>
<li><code>report.txt</code>: 详细分析报告</li>
</ul>
<h2 id="7">7. 使用示例</h2>
<h3 id="71">7.1 基本使用流程</h3>
<p>```python</p>
<h1 id="1_1">1. 运行完整管道</h1>
<p>python run_pipeline.py</p>
<h1 id="2_1">2. 可视化结果</h1>
<p>from visualize_solver_results import SAEVResultVisualizer
visualizer = SAEVResultVisualizer(data_dir="src")
visualizer.generate_report()
```</p>
<h3 id="72">7.2 单独运行求解器</h3>
<p>```python</p>
<h1 id="_7">构建求解器图</h1>
<p>python _08_build_solver_graph.py --t0 1 --H 6</p>
<h1 id="_8">求解最小费用流</h1>
<p>python _09_solve_graph_mincost.py
```</p>
<h3 id="73">7.3 自定义配置</h3>
<p>```python
from _01_network_config import NetworkConfig</p>
<h1 id="_9">修改配置</h1>
<p>cfg = NetworkConfig()
cfg.time_soc.dt_minutes = 10
cfg.costs_equity.vot = 2.0
cfg.flags.enable_service_reward = True
```</p>
<p>这个图数据结构设计实现了SAEV运营优化的复杂约束和目标，通过最小费用流算法求解最优的车辆调度方案。新增的可视化系统、管道执行系统和增强的求解器功能，使得整个系统更加完善和易用。</p>
</body>
</html>