# 网络化SAEV运营优化项目 - 图数据结构说明

## 项目概述

本项目实现了一个基于时空-电量网格的最小费用流优化模型，用于优化共享自动驾驶电动汽车(SAEV)的运营。模型在离散化的时空-电量网格上构建图结构，通过最小费用流算法求解最优的车辆调度方案。

## 核心数学建模

### 优化问题

**目标函数**：
$$\min \sum_{a \in \mathcal{A}} c_a x_a$$

**约束条件**：
1. **流守恒约束**：$\sum_{a \in \delta^-(v)} x_a - \sum_{a \in \delta^+(v)} x_a = s_v, \quad \forall v \in \mathcal{V}$
2. **容量约束**：$0 \leq x_a \leq u_a, \quad \forall a \in \mathcal{A}$
3. **非负约束**：$x_a \geq 0, \quad \forall a \in \mathcal{A}$

### 成本结构

每条弧的总成本由以下组件构成：

$$c_a = c^{\text{rep}}_a + c^{\text{chg-travel}}_a + c^{\text{occ}}_a + c^{\text{svc-gate}}_a + c^{\text{rep-reward}}_a + c^{\text{chg-reward}}_a + c^{\text{idle}}_a$$

其中：
- **正成本**：时间成本、占位成本、机会成本
- **负成本**：服务奖励、重定位收益、充电收益

## 新增功能特性

### 可视化分析系统
- **SAEVResultVisualizer**: 完整的求解结果可视化工具
- **多维度分析**: 流量分布、成本效益、时空演化、网络拓扑
- **交互式图表**: 支持plotly、folium等交互式可视化
- **自动化报告**: 生成完整的分析报告
- **实时监控**: 支持滚动窗口求解的实时结果展示
- **地图集成**: 基于地理信息的流量可视化
- **性能仪表板**: 关键运营指标的汇总展示

### 管道执行系统
- **run_pipeline.py**: 支持顺序执行多个脚本步骤
- **run_rolling_solve.py**: 滚动窗口求解的简化接口
- **日志记录**: 完整的执行日志和错误处理
- **超时控制**: 可配置的执行超时机制
- **重试机制**: 支持失败重试
- **回调函数**: 支持窗口完成后的自定义处理
- **实时输出**: 支持求解过程的实时状态显示

### 增强的求解器系统
- **负环检测**: 求解前自动检测负成本环，避免无界解
- **多求解器支持**: GLPK、CBC等求解器自动选择
- **性能优化**: 大规模问题的求解优化
- **滚动窗口**: 支持大规模时间范围的滚动优化
- **内存管理**: 优化的内存使用和垃圾回收
- **并行处理**: 支持多窗口并行求解
- **实时输出**: 支持求解过程的实时状态显示
- **数值稳定性**: 自动处理无穷大容量值，确保PuLP求解器兼容性

### 配置管理系统
- **NetworkConfig**: 统一的配置管理类
- **模块化配置**: 支持分模块的配置管理
- **默认值**: 所有配置参数都有合理的默认值
- **环境变量**: 支持环境变量覆盖配置
- **配置文件**: JSON格式的配置文件支持

## 1. 图的节点类型

### 1.1 真实网格节点 (Grid Nodes)

**节点表示**: `(i, t, ℓ)`
- `i`: 区域ID (zone)，来自 `zones.csv`
- `t`: 时间步 (time step)，离散化时间点
- `ℓ`: 电量等级 (SOC level)，0-100的离散电量值

**节点ID编码**: 
$$node\_id = (z_i \times n_t + t_i) \times n_l + l_i$$
其中 $z_i$, $t_i$, $l_i$ 分别是区域、时间、电量的索引。

**节点属性**:
- `node_id`: 唯一节点标识符
- `zone`: 区域ID
- `t`: 时间步
- `soc`: 电量等级
- `supply`: 节点供给量（仅初始时刻t₀有正供给）

### 1.2 伪节点 (Pseudo Nodes)

#### 1.2.1 服务闸门节点
- **`svc_in(i,j,t)`**: 服务进入闸门节点
- **`svc_out(i,j,t)`**: 服务退出闸门节点

用于将服务需求约束与时空推进解耦，实现"闸门弧"模式。

#### 1.2.2 充电队列节点
- **`q_in(k,p)`**: 充电站k在时间步p的进入队列节点
- **`q_out(k,p)`**: 充电站k在时间步p的退出队列节点

用于建模充电站的并发容量约束。

#### 1.2.3 超级汇点 (可选)
- **`sink`**: 超级汇点，用于平衡网络流

**伪节点ID生成**:
```python
def _pseudo_node_id(kind: str, *keys) -> int:
    s = f"{kind}|" + "|".join(map(str, keys))
    digest = hashlib.blake2b(s.encode('utf-8'), digest_size=8).digest()
    val = int.from_bytes(digest, byteorder='big', signed=False) & 0x7FFFFFFFFFFFFFFF
    return -int(val)  # 负数，避免与网格节点冲突
```

## 2. 图的边类型

### 2.1 基础弧类型

#### 2.1.1 空闲弧 (Idle Arcs)
- **类型**: `idle`
- **连接**: $(i,t,\ell) \rightarrow (i,t+1,\ell)$
- **含义**: 车辆在区域i停留一个时间步，电量不变
- **时间消耗**: $\tau = 1$步
- **电量消耗**: 0
- **成本**: $c^{\text{idle}}_a = \text{idle\_opportunity\_cost}$（默认10.0）

#### 2.1.2 重定位弧 (Reposition Arcs)
- **类型**: `reposition`
- **连接**: $(i,t,\ell) \rightarrow (j,t+\tau,\ell-\Delta\ell)$
- **含义**: 车辆从区域i重定位到区域j
- **时间消耗**: $\tau = \lceil \text{base\_minutes}/dt \rceil$
- **电量消耗**: $\Delta\ell = \text{compute\_multi\_timestep\_energy\_consumption}()$
- **约束**: 
  - $\ell \geq \max\{\Delta\ell, \text{min\_soc\_for\_reposition}\}$
  - $\tau \leq \text{max\_reposition\_tt}$
  - 起终点都在可达性集合R中
- **成本**: $c^{\text{rep}}_a + c^{\text{rep-reward}}_a$
  - 重定位成本：$\mathrm{VOT} \cdot \sum_{q=0}^{\tau-1} \gamma_{\text{rep\_p}}(t+q)$
  - 重定位收益：$-\gamma_{\text{rep}} \cdot \text{zone\_value}(t,j)$

### 2.2 服务弧 (Service Arcs) - 三段式结构

#### 2.2.1 服务进入弧
- **类型**: `svc_enter`
- **连接**: $(i,t,\ell) \rightarrow \text{svc\_in}(i,j,t)$
- **含义**: 车辆进入服务闸门
- **时间消耗**: $\tau = 0$
- **电量消耗**: 0
- **成本**: 0

#### 2.2.2 服务闸门弧
- **类型**: `svc_gate`
- **连接**: $\text{svc\_in}(i,j,t) \rightarrow \text{svc\_out}(i,j,t)$
- **含义**: 服务需求约束的容量弧
- **容量**: $u = D_{ijt}$ (当期需求)
- **成本**: $c^{\text{svc-gate}}_a = -\mathrm{VOT} \times w_{ijt}$（负成本奖励）
- **时间消耗**: $\tau = 0$

#### 2.2.3 服务退出弧
- **类型**: `svc_exit`
- **连接**: $\text{svc\_out}(i,j,t) \rightarrow (j,t+\tau,\ell-\Delta\ell)$
- **含义**: 车辆完成服务，到达目的地
- **时间消耗**: $\tau = \lceil \text{base\_minutes}/dt \rceil$
- **电量消耗**: $\Delta\ell = \text{compute\_multi\_timestep\_energy\_consumption}()$
- **成本**: 0

### 2.3 充电弧 (Charging Arcs) - 四段式结构

#### 2.3.1 去充电站弧
- **类型**: `tochg`
- **连接**: $(i,t,\ell) \rightarrow (\text{zone}(k),t+\tau,\ell-\Delta\ell)$
- **含义**: 车辆前往充电站k
- **时间消耗**: $\tau = \lceil \text{dist\_km}/(\text{avg\_speed\_kmh}/60)/dt \rceil$
- **电量消耗**: $\Delta\ell = \text{compute\_multi\_timestep\_energy\_consumption}()$
- **成本**: $c^{\text{chg-travel}}_a = \mathrm{VOT} \cdot \sum_{q=0}^{\tau-1} \beta_{\text{chg\_p1}}(t+q)$

#### 2.3.2 充电进入弧
- **类型**: `chg_enter`
- **连接**: $(\text{zone}(k),p,\ell) \rightarrow q\_\text{in}(k,p)$
- **含义**: 车辆进入充电站队列
- **时间消耗**: $\tau = 0$
- **电量消耗**: 0
- **成本**: 0

#### 2.3.3 充电占用弧
- **类型**: `chg_occ`
- **连接**: $q\_\text{in}(k,p) \rightarrow q\_\text{out}(k,p)$
- **含义**: 充电站并发容量约束
- **容量**: $u = \max\{1, \lfloor \text{plugs}_k \times \text{util\_factor}_k \times \text{queue\_relax\_factor} \rfloor\}$
- **成本**: $c^{\text{occ}}_a + c^{\text{chg-reward}}_a$
  - 占位成本：$\mathrm{VOT} \times \beta_{\text{chg\_p2}}(p)$
  - 充电收益：$-\alpha_{\text{chg}} \times \max\{\ell_{\text{to}} - \ell, 0\}$
- **时间消耗**: $\tau = 0$

#### 2.3.4 充电推进弧
- **类型**: `chg_step`
- **连接**: $q\_\text{out}(k,p) \rightarrow (\text{zone}(k),p+1,\ell')$
- **含义**: 充电时间推进，最后一步提升电量
- **时间消耗**: $\tau = 1$
- **电量变化**: 
  - 最后一步: $\ell' = \text{target\_soc}$
  - 其他步骤: $\ell' = \ell$
- **成本**: $c^{\text{chg-reward}}_a = -\alpha_{\text{chg}} \times \max\{\ell_{\text{to}} - \ell, 0\}$

### 2.4 超级汇点弧 (可选)
- **类型**: `to_sink`
- **连接**: $(i,t_{\text{hi}},\ell) \rightarrow \text{sink}$
- **含义**: 窗口结束时的流量平衡
- **容量**: 大数 ($10^{12}$)
- **成本**: cost_to_sink (默认0)

## 3. 边的权重属性

### 3.1 成本系数结构

每条弧的总成本由以下组件构成：
$$c_{\text{total}} = c_{\text{rep}} + c_{\text{chg\_travel}} + c_{\text{occ}} + c_{\text{svc\_gate}} + c_{\text{rep\_reward}} + c_{\text{chg\_reward}}$$

### 3.2 系数调度器 (CoeffProvider)

系统使用 `CoeffProvider` 类来管理时间可变的成本系数：

#### 3.2.1 系数来源
- **主要来源**: `coeff_schedule.csv` 文件，包含列 `[t, gamma_rep_p, beta_chg_p1, beta_chg_p2]`
- **后备来源**: 配置文件中的常数 `[gamma_rep, beta_toCHG, beta_chg]`
- **VOT系数**: 时间价值系数，来自配置 `cfg.costs_equity.vot`（默认1.0）

#### 3.2.2 系数获取函数
```python
def gamma_rep_p(self, t: int) -> float:
    """重定位时间成本系数"""
    return self.map_gamma_rep_p.get(int(t), self.gamma_rep_p_const)

def beta_chg_p1(self, t: int) -> float:
    """去充电行驶成本系数"""
    return self.map_beta_chg_p1.get(int(t), self.beta_chg_p1_const)

def beta_chg_p2(self, t: int) -> float:
    """充电占位成本系数"""
    return self.map_beta_chg_p2.get(int(t), self.beta_chg_p2_const)
```

#### 3.2.3 区间累加函数
```python
def gamma_rep_p_sum_over_window(self, t_start: int, tau: int) -> float:
    """重定位成本在时间窗口内的累加"""
    if tau <= 0: return 0.0
    if not self.has_schedule: return tau * self.gamma_rep_p_const
    return sum(self.gamma_rep_p(tp) for tp in range(t_start, t_start + tau))

def beta_chg_p1_sum_over_window(self, t_start: int, tau: int) -> float:
    """去充电行驶成本在时间窗口内的累加"""
    if tau <= 0: return 0.0
    if not self.has_schedule: return tau * self.beta_chg_p1_const
    return sum(self.beta_chg_p1(tp) for tp in range(t_start, t_start + tau))

def beta_chg_p2_sum_over_window(self, t_start: int, tau_tochg: int, tau_chg: int) -> float:
    """充电占位成本在充电时间内的累加"""
    if tau_chg <= 0: return 0.0
    if not self.has_schedule: return tau_chg * self.beta_chg_p2_const
    s_begin = t_start + tau_tochg
    return sum(self.beta_chg_p2(tp) for tp in range(s_begin, s_begin + tau_chg))
```

### 3.3 重定位成本 (c_rep)
- **适用弧**: `reposition`
- **数学函数**: 
  $$c_{\text{rep}} = VOT \times \sum_{q=0}^{\tau-1} \gamma_{\text{rep\_p}}(t+q)$$
- **实现函数**: `build_reposition_cost_coefficients_from_arcs()`
- **含义**: 重定位过程中的时间成本
- **系数来源**: `coeff_schedule.csv` 或配置常数 `cfg.costs_equity.gamma_rep`（默认1.0）

### 3.4 去充电行驶成本 (c_chg_travel)
- **适用弧**: `tochg`
- **数学函数**:
  $$c_{\text{chg\_travel}} = VOT \times \sum_{q=0}^{\tau-1} \beta_{\text{chg\_p1}}(t+q)$$
- **实现函数**: `build_charging_travel_costs_from_arcs()`
- **含义**: 前往充电站的时间成本
- **系数来源**: `coeff_schedule.csv` 或配置常数 `cfg.costs_equity.beta_toCHG`（默认1.0）

### 3.5 充电占位成本 (c_occ)
- **适用弧**: `chg_occ`
- **数学函数**:
  $$c_{\text{occ}} = VOT \times \beta_{\text{chg\_p2}}(p)$$
- **实现函数**: `build_charging_occupancy_costs_from_arcs()`
- **含义**: 充电站占用的时间成本
- **系数来源**: `coeff_schedule.csv` 或配置常数 `cfg.costs_equity.beta_chg`（默认1.0）

### 3.6 服务奖励 (c_svc_gate) - 负成本
- **适用弧**: `svc_gate`
- **数学函数**:
  $$c_{\text{svc\_gate}} = -VOT \times w_{ijt}$$
- **实现函数**: `build_service_reward_coefficients()`
- **含义**: 服务需求的奖励，鼓励满足需求
- **权重计算**:
  $$w_{ijt} = \text{cfg.costs_equity.unmet\_weight\_default} \quad \text{(默认权重，默认1.0)}$$
  $$w_{ijt} = \text{cfg.unmet\_weights\_overrides}(t,i,j) \quad \text{(特定组合覆盖)}$$
- **控制开关**: `cfg.flags.enable_service_reward`

### 3.7 重定位收益 (c_rep_reward) - 负成本
- **适用弧**: `reposition`
- **数学函数**:
  $$c_{\text{rep\_reward}} = -\gamma_{\text{rep}} \times \text{zone\_value}(t,j)$$
- **实现函数**: `build_zone_value_table()` + 重定位收益计算
- **含义**: 重定位到高需求区域的收益
- **区域价值计算**:
  $$\text{zone\_value\_raw}(t,j) = \max\left\{\sum_i D_{ijt}^{\text{out}} - \text{inv}_0(j), 0\right\}$$
  $$\text{zone\_value}(t,j) = \text{normalize}(\text{zone\_value\_raw}(t,j)) \quad \text{(归一化到 [0,1])}$$
- **归一化模式**:
  - `per_t_sum`: 按时段总和归一化
  - `per_t_max`: 按时段最大值归一化
  - `global_max`: 全局最大值归一化
  - `window_sum`: 窗口总和归一化
  - `none`: 不归一化
- **系数来源**: `cfg.costs_equity.gamma_reposition_reward`（默认1.0）
- **控制开关**: `cfg.flags.enable_reposition_reward`

### 3.8 充电收益 (c_chg_reward) - 负成本
- **适用弧**: `chg_occ`, `chg_step`
- **数学函数**:
  $$c_{\text{chg\_reward}} = -\alpha_{\text{chg}} \times \max\{\ell_{\text{to}} - \ell, 0\}$$
- **实现函数**: 基于 `chg_step` 弧的SOC变化计算
- **含义**: 充电电量提升的收益
- **SOC变化计算**:
  $$d_{\text{soc}} = (\ell_{\text{to}} - \ell) \cdot \text{clip}(\text{lower}=0) \quad \text{(只计算正的电量提升)}$$
  $$c_{\text{chg\_reward}} = -\beta_{\text{chg\_reward}} \times d_{\text{soc}}$$
- **系数来源**: `cfg.costs_equity.beta_chg_reward`（默认1.0）
- **控制开关**: `cfg.flags.enable_charging_reward`
- **注意**: 当前实现中主要基于 `chg_step` 弧的 `l_to` 列计算

### 3.9 成本合并机制

#### 3.9.1 成本系数合并函数
```python
def attach_costs_to_arcs_for_window(arc_df_win: pd.DataFrame) -> pd.DataFrame:
    """将各种成本系数合并到弧表中"""
    # 1. 计算各类成本系数
    parts = build_cost_coefficients_for_window(arc_df_win)
    
    # 2. 按弧类型合并成本
    out = arc_df_win.copy()
    for cost_type, coef_df in parts.items():
        if not coef_df.empty:
            out = _merge_with_keys(out, coef_df, keys, coef_col)
    
    # 3. 计算总成本
    out["coef_total"] = (
        out["coef_rep"] + out["coef_chg_travel"] + out["coef_chg_occ"] +
        out["coef_svc_gate"] + out["coef_rep_reward"] + out["coef_chg_reward"]
    )
    
    return out
```

#### 3.9.2 安全合并函数
```python
def _merge_with_keys(flow_df: pd.DataFrame, coef_df: pd.DataFrame, 
                    keys: List[str], coef_col: str) -> pd.DataFrame:
    """安全合并成本系数，避免列冲突"""
    # 优先使用 arc_id 作为合并键
    if "arc_id" in flow_df.columns and "arc_id" in coef_df.columns:
        use_keys = ["arc_id"]
    else:
        use_keys = [k for k in keys if (k in flow_df.columns and k in coef_df.columns)]
    
    # 合并并处理 NaN/±inf 值
    merged = flow_df.merge(coef_df, on=use_keys, how="left")
    merged[coef_col] = _to_finite_float(merged[coef_col], 0.0)
    
    return merged
```

#### 3.9.3 数值安全处理
```python
def _to_finite_float(s: pd.Series, default: float = 0.0) -> pd.Series:
    """将序列安全转换为有限浮点数"""
    x = pd.to_numeric(s, errors="coerce")
    x = x.where(np.isfinite(x), default)
    return x.astype(float)
```

### 3.10 容量约束

#### 3.10.1 服务闸门容量
- **弧类型**: `svc_gate`
- **容量**: $u = D_{ijt}$ (当期需求)
- **含义**: 限制当期可服务的最大需求

#### 3.10.2 充电站容量
- **弧类型**: `chg_occ`
- **容量**: $u = \max\{1, \lfloor \text{plugs}_k \times \text{util\_factor}_k \times \text{queue\_relax\_factor} \rfloor\}$
- **含义**: 限制充电站的并发充电数量

#### 3.10.3 其他弧容量
- **默认容量**: 大数 ($10^{12}$)
- **含义**: 仅由供给和连通性间接限流

## 4. 图构建流程

### 4.1 网格构建 (build_time_soc_grid.py)
1. 从 `zones.csv` 读取区域集合
2. 构建时间步序列 [start_step, end_step + overhang_steps]
3. 构建SOC等级序列 [0, 5, 10, ..., 100]
4. 生成所有 (zone, time, soc) 组合的网格节点
5. 从 `fleet_init.csv` 加载初始库存

### 4.2 可达性分析 (reachability.py)
1. 为每个区域选择最近充电站集合
2. 计算到站能耗
3. 构建可达性集合R，确保车辆能到达所有最近充电站

### 4.3 弧生成 (_04_arc_generators.py)
1. 生成idle弧
2. 生成service弧（三段式）
3. 生成reposition弧
4. 生成charging弧（四段式）
5. 移除自环

### 4.4 连通性裁剪 (connectivity.py)
1. 从初始库存构建源节点集合
2. 使用BFS进行前向/后向连通性分析
3. 保留连通弧，移除孤立弧

### 4.5 成本附加 (costs.py)
1. 计算各类弧的成本系数
2. 合并成本组件
3. 设置容量约束

### 4.6 求解器图构建 (_08_build_solver_graph.py)
1. 整合所有组件
2. 生成节点供给向量
3. 可选添加超级汇点
4. 输出求解器可用的图结构

### 4.7 最小费用流求解 (_09_solve_graph_mincost.py)
1. 读取求解器图结构
2. 负环检测（可选）
3. 构建线性规划模型
4. 选择求解器并求解
5. 输出最优流量分配

### 4.8 结果可视化 (visualize_solver_results.py)
1. 加载求解结果
2. 多维度分析
3. 生成可视化图表
4. 输出分析报告

## 5. 关键特性

### 5.1 滚动窗口优化
- 仅生成出发时刻在窗口内的弧
- 允许到达时刻跨窗口（Halo机制）
- 支持动态弧生成

### 5.2 伪节点设计
- 将容量约束与时空推进解耦
- 实现"闸门弧"和"占用链"模式
- 保持网络流的线性特性

### 5.3 可达性约束
- 确保车辆始终能到达充电站
- 使用ALL-NEAREST策略
- 动态SOC约束

### 5.4 成本结构
- 时间可变成本系数
- 负成本奖励机制
- 多目标平衡（成本最小化 + 需求满足）

### 5.5 配置系统
- 统一的配置管理
- 模块化配置结构
- 默认值支持

### 5.6 可视化系统
- 多维度分析
- 交互式图表
- 自动化报告生成
- 实时监控和状态展示
- 地图集成和地理可视化
- 性能仪表板

### 5.7 管道执行
- 顺序执行多个步骤
- 日志记录和错误处理
- 重试机制
- 滚动窗口求解支持
- 回调函数和实时输出
- 配置管理

## 6. 数据文件依赖

### 6.1 输入文件
- `zones.csv`: 区域定义
- `stations.csv`: 充电站信息
- `od_matrix.parquet`: 出行需求矩阵
- `base_ij.parquet`: 区域间基础信息
- `base_i2k.parquet`: 区域到充电站信息
- `coeff_schedule.csv`: 时间可变成本系数
- `coeff_energy.csv`: 能耗系数
- `fleet_init.csv`: 初始车队分布

### 6.2 中间文件
- `nodes.parquet`: 网格节点表
- `initial_inventory.parquet`: 初始库存
- `reachability.parquet`: 可达性表
- `*_arcs.parquet`: 各类弧表
- `node_indexer.pkl`: 节点索引器

### 6.3 输出文件
- `solver_graph/nodes.parquet`: 求解器节点表
- `solver_graph/arcs.parquet`: 求解器弧表
- `solver_graph/meta.json`: 图元数据
- `outputs/flows.parquet`: 最优流量分配
- `outputs/solve_summary.json`: 求解结果摘要

### 6.4 可视化输出
- `flow_summary.png`: 流量汇总分析图
- `spatiotemporal_flow.html`: 时空流量演化图
- `interactive_map.html`: 交互式地图
- `dashboard.html`: 综合仪表板
- `report.txt`: 详细分析报告

## 7. 使用示例

### 7.1 基本使用流程
```python
# 1. 运行完整管道
python run_pipeline.py

# 2. 可视化结果
from visualize_solver_results import SAEVResultVisualizer
visualizer = SAEVResultVisualizer(data_dir="src")
visualizer.generate_report()
```

### 7.2 滚动窗口求解
```python
# 使用默认配置运行滚动求解
python run_rolling_solve.py default

# 使用自定义参数运行滚动求解
python run_rolling_solve.py custom 1 12 3 1

# 分析滚动求解结果
python run_rolling_solve.py analyze outputs/rolling
```

### 7.3 单独运行求解器
```python
# 构建求解器图
python _08_build_solver_graph.py --t0 1 --H 6

# 求解最小费用流
python _09_solve_graph_mincost.py
```

### 7.4 自定义配置
```python
from network_config import NetworkConfig

# 修改配置
cfg = NetworkConfig()
cfg.time_soc.dt_minutes = 10
cfg.costs_equity.vot = 2.0
cfg.flags.enable_service_reward = True
```

### 7.5 高级可视化
```python
from visualize_solver_results import SAEVResultVisualizer

# 创建可视化器
visualizer = SAEVResultVisualizer(data_dir="src")

# 生成流量汇总分析
visualizer.plot_flow_summary()

# 生成时空演化图
visualizer.plot_spatiotemporal_flow()

# 生成交互式地图
visualizer.plot_interactive_map()

# 生成综合仪表板
visualizer.plot_dashboard()

# 生成完整报告
visualizer.generate_report()
```

## 8. 系统架构总结

这个图数据结构设计实现了SAEV运营优化的复杂约束和目标，通过最小费用流算法求解最优的车辆调度方案。系统采用模块化设计，包含以下核心组件：

### 8.1 核心优化引擎
- **时空-电量网格**: 离散化的三维状态空间
- **最小费用流算法**: 基于线性规划的全局优化
- **伪节点设计**: 将容量约束与时空推进解耦
- **滚动窗口优化**: 支持大规模时间范围的求解

### 8.2 数据处理管道
- **数据预处理**: 区域、站点、需求等基础数据
- **图构建**: 节点、弧、容量、成本的计算
- **可达性分析**: 确保车辆始终能到达充电站
- **连通性裁剪**: 优化图结构，提高求解效率

### 8.3 求解器系统
- **多求解器支持**: GLPK、CBC等求解器自动选择
- **负环检测**: 避免无界解
- **性能优化**: 内存管理和并行处理
- **实时监控**: 求解过程的状态显示

### 8.4 可视化分析
- **多维度分析**: 流量、成本、时空演化
- **交互式图表**: 支持钻取和筛选
- **地图集成**: 基于地理信息的可视化
- **自动化报告**: 生成详细的分析报告

### 8.5 管道执行
- **顺序执行**: 支持多步骤的自动化执行
- **错误处理**: 完整的日志记录和重试机制
- **配置管理**: 统一的参数配置
- **实时输出**: 支持求解过程的实时状态显示

新增的可视化系统、管道执行系统和增强的求解器功能，使得整个系统更加完善和易用，能够支持大规模SAEV运营优化问题的求解和分析。
